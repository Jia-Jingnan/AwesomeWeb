<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>节点的关系</title>
</head>
<body>
  <div id="box">
    <p>我是段落</p>
    <p>我是段落</p>
    <p>我是段落</p>
    <p>我是段落</p>
    <p id="fpara">我是段落A</p>
    <p id="para">我是段落B</p>
    <p>我是段落</p>
    <p>我是段落</p>
    <p>我是段落</p>
    <p>我是段落</p>
  </div>

  <script>
    var box = document.getElementById('box');
    var para = document.getElementById('para');

    // 封装一个函数，返回元素的所有子元素节点，类似childre功能
    function getChildren(node) {
      // 结果数组
      var children = [];
      // 遍历node节点的所有子节点，判断子节点的nodeType属性是不是1
      // 如果是1推入数组
      for (var i = 0; i < node.childNodes.length; i++){
        if (node.childNodes[i].nodeType == 1){
          children.push(node.childNodes[i]);
        }
      }

      return children;

    }

    console.log(getChildren(box));

    // 封装函数，可以返回元素的前一个兄弟元素节点，类似previousElementSibling的功能
    function getElementPrevSibling(node) {
      var o = node;

      // 使用while语句
      while (o.previousSibling != null){
        if (o.previousSibling.nodeType == 1){
          return o.previousSibling;
        }

        // 让o成为他的前一个节点,在进行判断
        o = o.previousSibling
      }

      return null;
    }

    console.log(getElementPrevSibling(para));
    console.log(getElementPrevSibling(fpara));

    // 返回元素的所有兄弟节点
    function getAllElementSibling(node) {
      // 前面元素的兄弟节点集合
      var prevs = [];
      // 后面元素的兄弟节点集合
      var nexts = [];

      var o = node;

      while (o.previousSibling != null){
        if (o.previousSibling.nodeType == 1){
          prevs.push(o.previousSibling);
        }
        o = o.previousSibling;
      }

      o = node;

      while (o.nextSibling != null){
        if (o.nextSibling.nodeType == 1){
          nexts.push(o.nextSibling);
        }
        o = o.nextSibling;
      }

      return prevs.concat(nexts);

    }

    console.log(getAllElementSibling(para));

  </script>
</body>
</html>